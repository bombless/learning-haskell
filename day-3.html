<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"/><title>4&nbsp;Day 3: Moving forward, albeit slowly</title><link rel="stylesheet" type="text/css" href="scribble.css" title="default"/><link rel="stylesheet" type="text/css" href="scribble-style.css" title="default"/><link rel="stylesheet" type="text/css" href="style.css" title="default"/><script type="text/javascript" src="scribble-common.js"></script><!--[if IE 6]><style type="text/css">.SIEHidden { overflow: hidden; }</style><![endif]--></head><body id="scribble-racket-lang-org"><div class="tocset"><div class="tocview"><div class="tocviewlist tocviewlisttopspace"><div class="tocviewtitle"><table cellspacing="0" cellpadding="0"><tr><td style="width: 1em;"><a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle" onclick="TocviewToggle(this,&quot;tocview_0&quot;);">&#9660;</a></td><td></td><td><a href="index.html" class="tocviewlink" data-pltdoc="x">Learning Haskell</a></td></tr></table></div><div class="tocviewsublisttop" style="display: block;" id="tocview_0"><table cellspacing="0" cellpadding="0"><tr><td align="right">1&nbsp;</td><td><a href="day-0.html" class="tocviewlink" data-pltdoc="x">Day 0:<span class="mywbr"> &nbsp;</span> A whole lot of nothing</a></td></tr><tr><td align="right">2&nbsp;</td><td><a href="day-1.html" class="tocviewlink" data-pltdoc="x">Day 1:<span class="mywbr"> &nbsp;</span> Getting up and running</a></td></tr><tr><td align="right">3&nbsp;</td><td><a href="day-2.html" class="tocviewlink" data-pltdoc="x">Day 2:<span class="mywbr"> &nbsp;</span> Into the rabbit hole</a></td></tr><tr><td align="right">4&nbsp;</td><td><a href="" class="tocviewselflink" data-pltdoc="x">Day 3:<span class="mywbr"> &nbsp;</span> Moving forward, albeit slowly</a></td></tr></table></div></div><div class="tocviewlist"><table cellspacing="0" cellpadding="0"><tr><td style="width: 1em;"><a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle" onclick="TocviewToggle(this,&quot;tocview_1&quot;);">&#9658;</a></td><td>4&nbsp;</td><td><a href="" class="tocviewselflink" data-pltdoc="x">Day 3:<span class="mywbr"> &nbsp;</span> Moving forward, albeit slowly</a></td></tr></table><div class="tocviewsublistbottom" style="display: none;" id="tocview_1"><table cellspacing="0" cellpadding="0"><tr><td align="right">4.1&nbsp;</td><td><a href="#%28part._.First__some_review%29" class="tocviewlink" data-pltdoc="x">First, some review</a></td></tr><tr><td align="right">4.2&nbsp;</td><td><a href="#%28part._.Getting_back_to_business%29" class="tocviewlink" data-pltdoc="x">Getting back to business</a></td></tr><tr><td align="right">4.3&nbsp;</td><td><a href="#%28part._.Some_closing_notes%29" class="tocviewlink" data-pltdoc="x">Some closing notes</a></td></tr></table></div></div></div><div class="tocsub"><div class="tocsubtitle">On this page:</div><table class="tocsublist" cellspacing="0"><tr><td><span class="tocsublinknumber">4.1<tt>&nbsp;</tt></span><a href="#%28part._.First__some_review%29" class="tocsubseclink" data-pltdoc="x">First, some review</a></td></tr><tr><td><span class="tocsublinknumber">4.2<tt>&nbsp;</tt></span><a href="#%28part._.Getting_back_to_business%29" class="tocsubseclink" data-pltdoc="x">Getting back to business</a></td></tr><tr><td><span class="tocsublinknumber">4.3<tt>&nbsp;</tt></span><a href="#%28part._.Some_closing_notes%29" class="tocsubseclink" data-pltdoc="x">Some closing notes</a></td></tr></table></div></div><div class="maincolumn"><div class="main"><div class="navsettop"><span class="navleft"><div class="nosearchform"></div>&nbsp;&nbsp;</span><span class="navright">&nbsp;&nbsp;<a href="day-2.html" title="backward to &quot;3 Day 2: Into the rabbit hole&quot;" data-pltdoc="x">&larr; prev</a>&nbsp;&nbsp;<a href="index.html" title="up to &quot;Learning Haskell&quot;" data-pltdoc="x">up</a>&nbsp;&nbsp;<span class="nonavigation">next &rarr;</span></span>&nbsp;</div><h3>4<tt>&nbsp;</tt><a name="(part._day-3)"></a>Day 3: Moving forward, albeit slowly</h3><p>Alright. It&rsquo;s been a few days since I finished up the last section. I ran back to Racket for a while
so I could feel safe amongst my brackets and parentheses, but I can&rsquo;t ignore Haskell that much longer.
Before I started this project, I think I viewed Haskell as little more than a pure, lazy language with
typeclasses for genericism which also happened to leverage monads to perform side effects. Now I&rsquo;m
feeling a little less sure of myself.</p><h4>4.1<tt>&nbsp;</tt><a name="(part._.First__some_review)"></a>First, some review</h4><p>I posted this to Reddit and Hacker News, and while the Hacker News discussion ended up, erm, shall we
say... "mixed", the Reddit comments were quite helpful.</p><p>I think the most exciting this to find out is that I was actually on the right track trying to get my
custom <span class="stt">Applicative</span> instance to work. The <span style="font-style: italic">correct</span> implementation of <span class="stt">Functor</span> was the
following, helpfully provided to me by <a href="http://www.reddit.com/user/tomejaguar">tomejaguar</a>.</p><blockquote class="code-block"><table cellspacing="0" cellpadding="0"><tr><td><p><span class="stt">newtype BinaryFunction a b c = BinaryFunction (a -&gt; b -&gt; c)</span></p></td></tr><tr><td><p><span class="stt">instance Functor (BinaryFunction a b) where</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">fmap a (BinaryFunction b) = BinaryFunction (\x y -&gt; a (b x y))</span></p></td></tr></table></blockquote><p>Of course, looking back on this, this feels painstakingly obvious. If <span class="stt">pure</span> hoists the function so
that it will ignore the first two arguments passed to it, this just doesn&rsquo;t pass those arguments
altogether. With that in place, my original attempt at <span class="stt">Applicative</span> should work fine.</p><blockquote class="code-block"><table cellspacing="0" cellpadding="0"><tr><td><p><span class="stt">instance Applicative (BinaryFunction a b) where</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">pure f = BinaryFunction (\_ _ -&gt; f)</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">(BinaryFunction f) &lt;*&gt; (BinaryFunction g) = BinaryFunction (\x y -&gt; f x y (g x y))</span></p></td></tr></table></blockquote><p>Now, admittedly, when I was trying to implement <span class="stt">BinaryFunction</span>, that original version using
<span class="stt">Compose</span> was sitting in the back of my head. After all, this is starting to look suspiciously
similar, isn&rsquo;t it? Add some record syntax to <span class="stt">BinaryFunction</span>, and you&rsquo;d basically have the
exact same thing. Indeed, as <a href="http://www.reddit.com/user/mjmrotek">mjmrotek</a> pointed out, <span class="stt">Compose</span> is just a more general version
of my attempt.</p><p>That said, I still don&rsquo;t really understand how <span class="stt">Compose</span> works. Here&rsquo;s the definition for
<span class="stt">Compose</span> itself, copied from the source.</p><blockquote class="code-block"><table cellspacing="0" cellpadding="0"><tr><td><p><span class="stt">newtype Compose f g a = Compose { getCompose :: f (g a) }</span></p></td></tr></table></blockquote><p>Just for completeness, let&rsquo;s look at the types for the constructor and field accessor.</p><blockquote class="code-tty"><table cellspacing="0" cellpadding="0"><tr><td><p><span class="stt">&gt; :t Compose</span></p></td></tr><tr><td><p><span class="stt">Compose :: f (g a) -&gt; Compose f g a</span></p></td></tr><tr><td><p><span class="stt">&gt; :t getCompose</span></p></td></tr><tr><td><p><span class="stt">getCompose :: Compose f g a -&gt; f (g a)</span></p></td></tr></table></blockquote><p>What exactly does <span class="stt">f (g a)</span> mean? I guess both <span class="stt">f</span> and <span class="stt">g</span> are higher-kinded types which each
take a single type parameter. So then what is <span class="stt">Compose min</span>?</p><blockquote class="code-tty"><table cellspacing="0" cellpadding="0"><tr><td><p><span class="stt">&gt; :t min</span></p></td></tr><tr><td><p><span class="stt">min :: Ord a =&gt; a -&gt; a -&gt; a</span></p></td></tr><tr><td><p><span class="stt">&gt; :t Compose min</span></p></td></tr><tr><td><p><span class="stt">Compose min :: Ord a =&gt; Compose ((-&gt;) a) ((-&gt;) a) a</span></p></td></tr></table></blockquote><p>Alright, so <span class="stt">f</span> and <span class="stt">g</span> are both <span class="stt">(a -&gt;)</span>, and <span class="stt">a</span> is just <span class="stt">a</span>. Composing these
together like in the constructor would yield <span class="stt">(a -&gt; (a -&gt; a))</span>, which is precisely the type I would
expect.</p><p>Now I can look at the instance for <span class="stt">Functor</span>.</p><blockquote class="code-block"><table cellspacing="0" cellpadding="0"><tr><td><p><span class="stt">instance (Functor f, Functor g) =&gt; Functor (Compose f g) where</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">fmap f (Compose x) = Compose (fmap (fmap f) x)</span></p></td></tr></table></blockquote><p>In the provided case, the type of <span class="stt">f</span> is <span class="stt">(a -&gt;)</span> and the type of <span class="stt">x</span> is <span class="stt">a -&gt; a -&gt; a</span>.
For functions, <span class="stt">fmap</span> is just <span class="stt">(.)</span>, so that becomes <span class="stt">(.) ((.) f) x</span>. Hmm, those two
immediate usages of composition are a little confusing.</p><blockquote class="code-tty"><table cellspacing="0" cellpadding="0"><tr><td><p><span class="stt">&gt; :t fmap (+1) (Compose max)</span></p></td></tr><tr><td><p><span class="stt">fmap (+1) (Compose max)</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">:: (Ord a, Num a) =&gt; Compose ((-&gt;) a) ((-&gt;) a) a</span></p></td></tr><tr><td><p><span class="stt">&gt; :t getCompose $ fmap (+1) (Compose max)</span></p></td></tr><tr><td><p><span class="stt">getCompose $ fmap (+1) (Compose max)</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">:: (Ord a, Num a) =&gt; a -&gt; a -&gt; a</span></p></td></tr></table></blockquote><p>I think I need to get my head around successive/nested composition a little bit more. Haskell&rsquo;s
"everything takes one value and returns one value" style, which effectively implements auto-currying,
can make composition a little more confusing than I&rsquo;m used to.</p><p>Let me break this down a little more.</p><blockquote class="code-tty"><table cellspacing="0" cellpadding="0"><tr><td><p><span class="stt">&gt; :t (.) ((.) (+1)) max</span></p></td></tr><tr><td><p><span class="stt">(.) ((.) (+1)) max :: (Ord c, Num c) =&gt; c -&gt; c -&gt; c</span></p></td></tr><tr><td><p><span class="stt">&gt; :t (.)</span></p></td></tr><tr><td><p><span class="stt">(.) :: (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c</span></p></td></tr><tr><td><p><span class="stt">&gt; :t ((.) (+1))</span></p></td></tr><tr><td><p><span class="stt">((.) (+1)) :: Num c =&gt; (a -&gt; c) -&gt; a -&gt; c</span></p></td></tr></table></blockquote><p>The type of <span class="stt">(.)</span> is, of course, obvious, though looking at it did remind me something important. I
should probably be thinking about function types like <span class="stt">a -&gt; a -&gt; a</span> as <span class="stt">a -&gt; (a -&gt; a)</span>, which
would obviously satisfy the type <span class="stt">a -&gt; b</span> where <span class="stt">b</span> is just <span class="stt">a -&gt; a</span>.</p><p>With this in mind, what is <span class="stt">(.) (+1)</span>? Well, <span class="stt">(+1)</span> is just a unary function, so it makes
filling in the type for the first argument of <span class="stt">(.)</span> obvious. The result of the expression is a
function that takes a function that operates on any input and converts it to a number, which is then
passed to the incrementing function, which creates the final result.</p><p>To keep things clearer as I try to juggle types in my head, I&rsquo;ll replace that expression with
<span class="stt">\f x -&gt; (f x) + 1</span>. Substituting that into the original expression yields <span class="stt">max . (\f x -&gt; (f x)
+ 1)</span>. Again, the composition takes the result of the <span style="font-style: italic">second</span> argument, then passes it to the
first argument. Therefore, the resulting function will take two numbers, find the maximum, and then
increment the result.</p><p>This explains the behavior of that wacky <span class="stt">((.).(.))</span> function that someone commented about on the
reddit thread.</p><blockquote class="code-tty"><table cellspacing="0" cellpadding="0"><tr><td><p><span class="stt">&gt; :t ((.).(.))</span></p></td></tr><tr><td><p><span class="stt">((.).(.)) :: (b -&gt; c) -&gt; (a -&gt; a1 -&gt; b) -&gt; a -&gt; a1 -&gt; c</span></p></td></tr></table></blockquote><p>This actually seems to be function composition for a unary function with a binary function, which is
sort of cool. In Racket, it would just be <span class="stt">(compose f g)</span>, even if <span class="stt">g</span> required two arguments,
but in Haskell, all functions are <span style="font-style: italic">really</span> unary&#8212;there&rsquo;s no luxury of functions which cannot be
partially applied.</p><p>What happens if I add more dots?</p><blockquote class="code-tty"><table cellspacing="0" cellpadding="0"><tr><td><p><span class="stt">&gt; :t (.).(.).(.)</span></p></td></tr><tr><td><p><span class="stt">(.).(.).(.)</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">:: (b -&gt; c) -&gt; (a -&gt; a1 -&gt; a2 -&gt; b) -&gt; a -&gt; a1 -&gt; a2 -&gt; c</span></p></td></tr></table></blockquote><p>The pattern does, indeed, continue. That&rsquo;s sort of nice to know. I feel like I should be able to
logically understand that <span style="font-style: italic">of course</span> that&rsquo;s what composing composition does, but I definitely
cannot do that yet.</p><p>Now that all that&rsquo;s figured out, what about <span class="stt">Applicative</span> for <span class="stt">Compose</span>?</p><blockquote class="code-block"><table cellspacing="0" cellpadding="0"><tr><td><p><span class="stt">instance (Applicative f, Applicative g) =&gt; Applicative (Compose f g) where</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">pure x = Compose (pure (pure x))</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">Compose f &lt;*&gt; Compose x = Compose ((&lt;*&gt;) &lt;$&gt; f &lt;*&gt; x)</span></p></td></tr></table></blockquote><p>Wow. I have no idea what that does.</p><p>Okay, <span class="stt">pure (pure x))</span> is obvious (and I almost wish it were written <span class="stt">Compose . pure . pure</span>...,
I think I&rsquo;m already losing myself to Haskell&rsquo;s convenient composition), but what about that crazy mess
for <span class="stt">&lt;*&gt;</span>?</p><blockquote class="code-tty"><table cellspacing="0" cellpadding="0"><tr><td><p><span class="stt">&gt; :t (\f x -&gt; (&lt;*&gt;) &lt;$&gt; f &lt;*&gt; x)</span></p></td></tr><tr><td><p><span class="stt">(\f x -&gt; (&lt;*&gt;) &lt;$&gt; f &lt;*&gt; x)</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">:: (Applicative f1, Applicative f) =&gt;</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">f (f1 (a -&gt; b)) -&gt; f (f1 a) -&gt; f (f1 b)</span></p></td></tr></table></blockquote><p>Wow! I have no idea how that&rsquo;s implemented, but the type actually seems to make some sense! Given an
instance of <span class="stt">Applicative</span> wrapped in another <span class="stt">Applicative</span> from <span class="stt">a -&gt; b</span>, then providing
<span class="stt">a</span> yields <span class="stt">b</span>. I still have lots of questions, though. In this example, what is <span class="stt">f</span>? What is
<span class="stt">f1</span>?</p><p>This is one of those situations where I wish I could somehow have GHC tell me the types instantiated
with something. I&rsquo;m not even really sure what that means, though, since the types could clearly be
anything. Whatever. Let me just reason it out myself.</p><p>I think where this is sort of tripping me up is how the <span class="stt">Applicative</span> instance is for
<span class="stt">Compose f g</span>. Obviously, this is because <span class="stt">Applicative</span> wants a type of kind <span class="stt">* -&gt; *</span>, so the
<span class="stt">Compose</span> type constructor needs to be partially applied. But what does that mean? In the original
type <span class="stt">Compose f (g a)</span>, what is <span class="stt">a</span>?</p><p>If <span class="stt">Compose</span> is created with <span class="stt">(+)</span>, then <span class="stt">a</span> is simply any type that is a member of the
<span class="stt">Num</span> typeclass. The <span class="stt">a</span> type corresponds to the function&rsquo;s return value while <span class="stt">f</span> and <span class="stt">g</span>
correspond to its inputs. I guess more generally, <span class="stt">f</span> could be a function type, but <span class="stt">g</span> could be
some entirely unrelated functor.</p><p>So back to the original <span class="stt">Applicative</span> instance. The mixing of infix and prefix operators is still
something I find a little confusing, so let me make everything prefix to make things more clear.</p><blockquote class="code-tty"><table cellspacing="0" cellpadding="0"><tr><td><p><span class="stt">&gt; :t \f x -&gt; ((&lt;*&gt;) ((&lt;$&gt;) (&lt;*&gt;) f) x)</span></p></td></tr><tr><td><p><span class="stt">\f x -&gt; ((&lt;*&gt;) ((&lt;$&gt;) (&lt;*&gt;) f) x)</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">:: (Applicative f1, Applicative f) =&gt;</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">f (f1 (a -&gt; b)) -&gt; f (f1 a) -&gt; f (f1 b)</span></p></td></tr></table></blockquote><p>Same thing, just all prefix. Working from the inside-out, what the hell is <span class="stt">(&lt;*&gt;) (&lt;$&gt;)</span>?</p><blockquote class="code-tty"><table cellspacing="0" cellpadding="0"><tr><td><p><span class="stt">&gt; :t (&lt;*&gt;) (&lt;$&gt;)</span></p></td></tr><tr><td><p><span class="stt">(&lt;*&gt;) (&lt;$&gt;) :: Functor f =&gt; ((a -&gt; b) -&gt; f a) -&gt; (a -&gt; b) -&gt; f b</span></p></td></tr></table></blockquote><p>Hmm. I still don&rsquo;t really get how this works.</p><p>You know what? Screw it. I could probably spend hours dissecting this tiny, insignificant piece of
code. How could such a small snippet be such a headache? I <span style="font-style: italic">think</span> I can explain this away with
some relatively high-level conceptual reasoning.</p><p>In the <span class="stt">Applicative</span> instance for <span class="stt">Compose</span>, both of its first two type parameters are
<span class="stt">Applicative</span>, so the value contained is wrapped in two layers to <span class="stt">Applicative</span> containers.
(This "container" metaphor is wrong, and I already <span style="font-style: italic">know</span> it to be wrong, since the containers
simply seem to be manifested by the types and don&rsquo;t actually box anything, but I get that. I think
my mental model is sound, at least for that piece.) Therefore, the type for <span class="stt">&lt;*&gt;</span> for <span class="stt">Compose</span>
is obvious&#8212;it takes an applicable value wrapped in the two layers of <span class="stt">Applicative</span>s, a value that
can be supplied to the first value (also wrapped in the same two layers), and finally produces the
result of that application (still wrapped in the same two layers).</p><p>With functions, this idea of "application" is fairly explicit, since it literally means function
application. With other types, though, it could mean various other things. The name <span class="stt">Applicative</span>
is starting to make some sense to me&#8212;it generalizes the idea of function application to other types.
Sort of neat, but not quite within my grasp to understand in full just yet.</p><p>Perhaps I&rsquo;ll figure it out in time. Now, I think, is not that time.</p><h4>4.2<tt>&nbsp;</tt><a name="(part._.Getting_back_to_business)"></a>Getting back to business</h4><p>Phew. That was a lot of confusing, abstract thinking about types. I think I&rsquo;m ready to go back to
something simple. Something practical. Alright, random college class, what have you got to show me?</p><p>Aha! Writing a programming language interpreter. Should be <span style="font-style: italic">downright easy</span> in comparison to
what I&rsquo;ve just dealt with.</p><p>Alright, so the assignment provides a bunch of datatypes to represent the AST of an arbitrary
imperative programming language. The assignment is about manipulating those ASTs. Seems simple enough.
The first exercise deals with manipulating <span class="stt">State</span>s, which represent variable bindings in our
mini-language.</p><p>A <span class="stt">State</span> is actually simply a <span class="stt">String -&gt; Int</span>, and an empty state maps anything to <span class="stt">0</span>. This
allows us to write an <span class="stt">extend</span> function that extends a given state, making this task relatively
straightforward.</p><blockquote class="code-block"><table cellspacing="0" cellpadding="0"><tr><td><p><span class="stt">extend :: State -&gt; String -&gt; Int -&gt; State</span></p></td></tr><tr><td><p><span class="stt">extend s identifier value =</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">\identifier' -&gt; if identifier == identifier'</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">then value</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">else s identifier'</span></p></td></tr></table></blockquote><p>Neat and simple. Defining the <span class="stt">empty</span> state is obviously trivial.</p><blockquote class="code-block"><table cellspacing="0" cellpadding="0"><tr><td><p><span class="stt">empty :: State</span></p></td></tr><tr><td><p><span class="stt">empty _ = 0</span></p></td></tr></table></blockquote><p>Now we can implement an <span class="stt">evalE</span> function, simply to evaluate expressions. It will take a <span class="stt">State</span>
for resolving variable lookups.</p><blockquote class="code-block"><table cellspacing="0" cellpadding="0"><tr><td><p><span class="stt">evalE :: State -&gt; Expression -&gt; Int</span></p></td></tr><tr><td><p><span class="stt">evalE st (Var s) = st s</span></p></td></tr><tr><td><p><span class="stt">evalE _</span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">(Val i) = i</span></p></td></tr><tr><td><p><span class="stt">evalE st (Op e op e') =</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">case op of</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">Plus</span><span class="hspace">&nbsp;&nbsp;&nbsp;</span><span class="stt">-&gt; v + v'</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">Minus</span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">-&gt; v - v'</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">Times</span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">-&gt; v * v'</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">Divide -&gt; v `div` v'</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">Gt</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">-&gt; bTi $ v &gt;</span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">v'</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">Ge</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">-&gt; bTi $ v &gt;= v'</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">Lt</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">-&gt; bTi $ v &lt;</span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">v'</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">Le</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">-&gt; bTi $ v &lt;= v'</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">Eql</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">-&gt; bTi $ v == v'</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">where v</span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">= evalE st e</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">v' = evalE st e'</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">bTi b = if b then 1 else 0</span></p></td></tr></table></blockquote><p>Using <span class="stt">case</span> for the operator pattern-matching makes that relatively clean. Next up, implementing
desugaring! "Desugaring" is, after all, the lesser cousin of macros, so this is something I can get
behind.</p><blockquote class="code-block"><table cellspacing="0" cellpadding="0"><tr><td><p><span class="stt">desugar :: Statement -&gt; DietStatement</span></p></td></tr><tr><td><p><span class="stt">desugar (Assign s e)</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">= DAssign s e</span></p></td></tr><tr><td><p><span class="stt">desugar (Incr s)</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">= DAssign s (Op (Var s) Plus (Val 1))</span></p></td></tr><tr><td><p><span class="stt">desugar (If e s s')</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">= DIf e (desugar s) (desugar s')</span></p></td></tr><tr><td><p><span class="stt">desugar (While e s)</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">= DWhile e (desugar s)</span></p></td></tr><tr><td><p><span class="stt">desugar (Sequence s s') = DSequence (desugar s) (desugar s')</span></p></td></tr><tr><td><p><span class="stt">desugar Skip</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">= DSkip</span></p></td></tr><tr><td><p><span class="stt">desugar (For pre cond post s) =</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">DSequence (desugar pre)</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">(DWhile cond (DSequence (desugar s)</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">(desugar post)))</span></p></td></tr></table></blockquote><p>Mmm, my parentheses, how I&rsquo;ve missed you. Implementing this reminds me how much I like that Lisp
expressions are basically just ASTs already.</p><p>Anyway, now we can create a simple statement evaluator.</p><blockquote class="code-block"><table cellspacing="0" cellpadding="0"><tr><td><p><span class="stt">evalSimple :: State -&gt; DietStatement -&gt; State</span></p></td></tr><tr><td><p><span class="stt">evalSimple st (DAssign s e) = extend st s (evalE st e)</span></p></td></tr><tr><td><p><span class="stt">evalSimple st (DIf e s s') = if evalE st e /= 0 then evalSimple st s</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">else evalSimple st s'</span></p></td></tr><tr><td><p><span class="stt">evalSimple st (DWhile e s) = if evalE st e /= 0 then evalSimple (evalSimple st s) (DWhile e s)</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">else st</span></p></td></tr><tr><td><p><span class="stt">evalSimple st (DSequence s s') = evalSimple (evalSimple st s) s'</span></p></td></tr><tr><td><p><span class="stt">evalSimple st DSkip = st</span></p></td></tr></table></blockquote><p>Quite nice; maybe even pretty! Of course, none of these are really demonstrating any of Haskell&rsquo;s
unique features&#8212;all of these could be implemented more or less the same in any functional programming
language. This assignment, especially, gives me a very Racket-y vibe. It would definitely be simple to
port this almost verbatim to Racket using its extensive pattern-matching facilities.</p><p>Now the final bit is to implement a <span class="stt">run</span> function to run programs. For some <span style="font-style: italic">baffling</span>
reason, the homework assignment includes this note:</p><blockquote class="blockquote"><p><span style="font-style: italic">Note:</span> <span class="stt">run</span> should be defined in terms of <span class="stt">desugar</span> and <span class="stt">evalSimple</span>. It should
not be implemented from scratch.</p></blockquote><p>After all that, whoever would implement <span class="stt">run</span> from scratch must be out of their mind. I&rsquo;m almost
amused to imagine that some poor student would be too clueless to understand how to implement <span class="stt">run</span>
using the functions that have already been implemented considering how <span style="font-style: italic">stupidly easy</span> its
implementation is.</p><blockquote class="code-block"><table cellspacing="0" cellpadding="0"><tr><td><p><span class="stt">run :: State -&gt; Statement -&gt; State</span></p></td></tr><tr><td><p><span class="stt">run st = evalSimple st . desugar</span></p></td></tr></table></blockquote><p>And that&rsquo;s it! An extremely simple interpreter for an AST in Haskell. As I stated above, nothing very
special going on here, but a cool example of Haskell&rsquo;s simple functional programming features. And
honestly, it was a nice break after all that nonsense about <span class="stt">Applicative</span> and <span class="stt">Compose</span>.</p><h4>4.3<tt>&nbsp;</tt><a name="(part._.Some_closing_notes)"></a>Some closing notes</h4><p>I&rsquo;m sorry if this was a relatively boring day in comparison to the last one. I almost feel a little
guilty for throwing in the towel with understanding the <span class="stt">Compose</span> implementation, but I&rsquo;m in over
my head on that one. Perhaps for another time.</p><p>Anyway, I&rsquo;d like to note a few extra things that either happened in between the previous day and this
one or things I&rsquo;ve come across while writing this.</p><p>First of all, I had a few people recommend avoiding <span class="stt">$</span>. I used it in one spot while writing this
assignment, but in general, I&rsquo;ve made a decision to avoid using it unless it really improves the
clarity of my code. At first I was a little afraid to sprinkle parens everywhere considering my Lisp
experience, but I think a balance has become a little more apparent.</p><p>I&rsquo;ve come to a similar conclusion with point-free code. I did, for example, write <span class="stt">run</span> using
point-free style, but in most cases, it doesn&rsquo;t feel like it&rsquo;s conducive to writing readable code.
Even with <span class="stt">run</span>, it wasn&rsquo;t truly <span style="font-style: italic">completely</span> point-free.</p><blockquote class="code-block"><table cellspacing="0" cellpadding="0"><tr><td><p><span class="stt">run :: State -&gt; Statement -&gt; State</span></p></td></tr><tr><td><p><span class="stt">run st = evalSimple st . desugar</span></p></td></tr></table></blockquote><p>I <span style="font-style: italic">could</span> implement that with <span class="stt">(. evalSimple) . desugar</span>, but... why? That&rsquo;s completely
useless. On the other hand, expressing the second parameter as being related to composition of
<span class="stt">evalSimple</span> and <span class="stt">desugar</span> makes logical sense.</p><p>Anyway, I think that&rsquo;s it for now. Honestly, at this point, I&rsquo;m just excited to get to monads, since
I think they&rsquo;re a really cool concept, and I think I <span style="font-style: italic">mostly</span> understand how they work. Soon!</p><div class="navsetbottom"><span class="navleft"><div class="nosearchform"></div>&nbsp;&nbsp;</span><span class="navright">&nbsp;&nbsp;<a href="day-2.html" title="backward to &quot;3 Day 2: Into the rabbit hole&quot;" data-pltdoc="x">&larr; prev</a>&nbsp;&nbsp;<a href="index.html" title="up to &quot;Learning Haskell&quot;" data-pltdoc="x">up</a>&nbsp;&nbsp;<span class="nonavigation">next &rarr;</span></span>&nbsp;</div></div></div><div id="contextindicator">&nbsp;</div></body></html>