<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"/><title>3&nbsp;Day 2: Into the rabbit hole</title><link rel="stylesheet" type="text/css" href="scribble.css" title="default"/><link rel="stylesheet" type="text/css" href="scribble-style.css" title="default"/><link rel="stylesheet" type="text/css" href="style.css" title="default"/><script type="text/javascript" src="scribble-common.js"></script><!--[if IE 6]><style type="text/css">.SIEHidden { overflow: hidden; }</style><![endif]--></head><body id="scribble-racket-lang-org"><div class="tocset"><div class="tocview"><div class="tocviewlist tocviewlisttopspace"><div class="tocviewtitle"><table cellspacing="0" cellpadding="0"><tr><td style="width: 1em;"><a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle" onclick="TocviewToggle(this,&quot;tocview_0&quot;);">&#9660;</a></td><td></td><td><a href="index.html" class="tocviewlink" data-pltdoc="x">Learning Haskell</a></td></tr></table></div><div class="tocviewsublisttop" style="display: block;" id="tocview_0"><table cellspacing="0" cellpadding="0"><tr><td align="right">1&nbsp;</td><td><a href="day-0.html" class="tocviewlink" data-pltdoc="x">Day 0:<span class="mywbr"> &nbsp;</span> A whole lot of nothing</a></td></tr><tr><td align="right">2&nbsp;</td><td><a href="day-1.html" class="tocviewlink" data-pltdoc="x">Day 1:<span class="mywbr"> &nbsp;</span> Getting up and running</a></td></tr><tr><td align="right">3&nbsp;</td><td><a href="" class="tocviewselflink" data-pltdoc="x">Day 2:<span class="mywbr"> &nbsp;</span> Into the rabbit hole</a></td></tr></table></div></div><div class="tocviewlist"><table cellspacing="0" cellpadding="0"><tr><td style="width: 1em;"><a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle" onclick="TocviewToggle(this,&quot;tocview_1&quot;);">&#9658;</a></td><td>3&nbsp;</td><td><a href="" class="tocviewselflink" data-pltdoc="x">Day 2:<span class="mywbr"> &nbsp;</span> Into the rabbit hole</a></td></tr></table><div class="tocviewsublistbottom" style="display: none;" id="tocview_1"><table cellspacing="0" cellpadding="0"><tr><td align="right">3.1&nbsp;</td><td><a href="#%28part._.Mastermind_in_.Haskell%29" class="tocviewlink" data-pltdoc="x"><span style="font-style: italic">Mastermind</span> in Haskell</a></td></tr><tr><td align="right">3.2&nbsp;</td><td><a href="#%28part._.Oh_right__types_are_complicated%29" class="tocviewlink" data-pltdoc="x">Oh right, types are <span style="font-style: italic">complicated</span></a></td></tr><tr><td align="right">3.3&nbsp;</td><td><a href="#%28part._.It_s_types_all_the_way_down%29" class="tocviewlink" data-pltdoc="x">It&rsquo;s types all the way down</a></td></tr><tr><td align="right">3.4&nbsp;</td><td><a href="#%28part._.Back_to_.Mastermind%29" class="tocviewlink" data-pltdoc="x">Back to <span style="font-style: italic">Mastermind</span></a></td></tr></table></div></div></div><div class="tocsub"><div class="tocsubtitle">On this page:</div><table class="tocsublist" cellspacing="0"><tr><td><span class="tocsublinknumber">3.1<tt>&nbsp;</tt></span><a href="#%28part._.Mastermind_in_.Haskell%29" class="tocsubseclink" data-pltdoc="x"><span style="font-style: italic">Mastermind</span> in Haskell</a></td></tr><tr><td><span class="tocsublinknumber">3.2<tt>&nbsp;</tt></span><a href="#%28part._.Oh_right__types_are_complicated%29" class="tocsubseclink" data-pltdoc="x">Oh right, types are <span style="font-style: italic">complicated</span></a></td></tr><tr><td><span class="tocsublinknumber">3.2.1<tt>&nbsp;</tt></span><a href="#%28part._.Monads__functors__and_applicative_functors%29" class="tocsubseclink" data-pltdoc="x">Monads, functors, and applicative functors</a></td></tr><tr><td><span class="tocsublinknumber">3.3<tt>&nbsp;</tt></span><a href="#%28part._.It_s_types_all_the_way_down%29" class="tocsubseclink" data-pltdoc="x">It&rsquo;s types all the way down</a></td></tr><tr><td><span class="tocsublinknumber">3.3.1<tt>&nbsp;</tt></span><a href="#%28part._.Build_your_own_instances__maybe_%29" class="tocsubseclink" data-pltdoc="x">Build your own instances&#8230; maybe?</a></td></tr><tr><td><span class="tocsublinknumber">3.4<tt>&nbsp;</tt></span><a href="#%28part._.Back_to_.Mastermind%29" class="tocsubseclink" data-pltdoc="x">Back to <span style="font-style: italic">Mastermind</span></a></td></tr></table></div></div><div class="maincolumn"><div class="main"><div class="navsettop"><span class="navleft"><div class="nosearchform"></div>&nbsp;&nbsp;</span><span class="navright">&nbsp;&nbsp;<a href="day-1.html" title="backward to &quot;2 Day 1: Getting up and running&quot;" data-pltdoc="x">&larr; prev</a>&nbsp;&nbsp;<a href="index.html" title="up to &quot;Learning Haskell&quot;" data-pltdoc="x">up</a>&nbsp;&nbsp;<span class="nonavigation">next &rarr;</span></span>&nbsp;</div><h3>3<tt>&nbsp;</tt><a name="(part._day-2)"></a>Day 2: Into the rabbit hole</h3><p>Okay. Time to keep going. Hopefully things will get a little more interesting this time.</p><p>The next section is entitled <span style="font-style: italic">Polymorphism and Functional Programming</span>. This at least sounds
more interesting! Let&rsquo;s take a look at what it has to offer.</p><h4>3.1<tt>&nbsp;</tt><a name="(part._.Mastermind_in_.Haskell)"></a><span style="font-style: italic">Mastermind</span> in Haskell</h4><p>Apparently, this homework assignment is based on the <span style="font-style: italic">Mastermind</span> puzzle game, which is
actually a pretty cool concept. The introduction mentions something about typeclass constraints, which
I actually remember from my pervious dabblings, though it looks like they haven&rsquo;t been formally
introduced in this class yet.</p><p>The first assignment is to write a function that takes two <span class="stt">Code</span> instances, which are just lists
of colors, and finds how many "exact" matches they share. To me, this sounds like a useful time to use
<span class="stt">zip</span>! Then I guess I could use <span class="stt">foldl</span><span class="stt">&rsquo;</span><span class="stt"></span> and sum everything manually, but I&rsquo;m sure there&rsquo;s a
nicer way.</p><p>Well, first, I can use <span class="stt">map</span> with zip to get a list of <span class="stt">Bool</span>s, right? Although then I&rsquo;d need a
function of type <span class="stt">(a, a) -&gt; Bool</span>. To Hoogle I go again.</p><p>Hrm. Still nothing. Well, I&rsquo;m sure there&rsquo;s a nice way of doing it, but for now I can just write my own
helper function.</p><blockquote class="code-block"><table cellspacing="0" cellpadding="0"><tr><td><p><span class="stt">pairEq :: (a, a) -&gt; Bool</span></p></td></tr><tr><td><p><span class="stt">pairEq (a, b) = a == b</span></p></td></tr></table></blockquote><p>Nope, that still complains about types. Oh, this is where typeclasses come in, right? I seem to
remember the relevant typeclass is called <span class="stt">Eq</span>, let&rsquo;s see if I remember the syntax.</p><blockquote class="code-block"><table cellspacing="0" cellpadding="0"><tr><td><p><span class="stt">pairEq :: Eq a =&gt; (a, a) -&gt; Bool</span></p></td></tr><tr><td><p><span class="stt">pairEq (a, b) = a == b</span></p></td></tr></table></blockquote><p>There we go. GHC is happy now. Now things should be fairly easy...</p><blockquote class="code-block"><table cellspacing="0" cellpadding="0"><tr><td><p><span class="stt">exactMatches :: Code -&gt; Code -&gt; Int</span></p></td></tr><tr><td><p><span class="stt">exactMatches xs ys = map pairEq pairs</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">where pairs = zip xs ys</span></p></td></tr></table></blockquote><p>Wait, no, now I have a <span class="stt">[Bool]</span>. I need to count up all the <span class="stt">True</span> values. In Racket, I&rsquo;d use
<span class="stt">count</span>. Does Haskell have something similar? A quick query for <span class="stt">[Bool] -&gt; Int</span> doesn&rsquo;t give me
anything helpful (c&rsquo;mon Hoogle, I talked about how cool you were and you&rsquo;ve done nothing but let me
down), though I guess it wouldn&rsquo;t be hard to piece together with some simple function composition.</p><blockquote class="code-block"><table cellspacing="0" cellpadding="0"><tr><td><p><span class="stt">exactMatches :: Code -&gt; Code -&gt; Int</span></p></td></tr><tr><td><p><span class="stt">exactMatches xs ys = length . filter id $ map pairEq pairs</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">where pairs = zip xs ys</span></p></td></tr></table></blockquote><p>There we go! It&rsquo;s even pretty elegant, too, except perhaps for the <span class="stt">pairEq</span> function in there.
Moving on, the next step is to write a function that counts how many of each color there are within a
list. The code provided includes a <span class="stt">colors</span> list that simply contains all of the possible elements.</p><blockquote class="code-block"><table cellspacing="0" cellpadding="0"><tr><td><p><span class="stt">colors :: [Peg]</span></p></td></tr><tr><td><p><span class="stt">colors = [Red, Green, Blue, Yellow, Orange, Purple]</span></p></td></tr></table></blockquote><p>I have mixed feelings about that, I guess. It feels a little redundant to have to manually list out
all the elements when the information is known statically, and updating the list will be necessary if
the <span class="stt">Peg</span> type changes. In Racket, writing a macro for this would be trivial, but alas, this is
Haskell. Perhaps there is a way, I&rsquo;m just not aware of it.</p><p>Anyway, this isn&rsquo;t really a hard problem. Here&rsquo;s my solution.</p><blockquote class="code-block"><table cellspacing="0" cellpadding="0"><tr><td><p><span class="stt">countColors :: Code -&gt; [Int]</span></p></td></tr><tr><td><p><span class="stt">countColors ps = map countColor colors</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">where countColor c = length $ filter (== c) ps</span></p></td></tr></table></blockquote><p>Maybe it could be better? I don&rsquo;t know. It looks fine to me. Now I&rsquo;m supposed to use that function to
find <span class="stt">all possible</span> matches between two codes, but order doesn&rsquo;t matter. This is pretty simple,
too.</p><blockquote class="code-block"><table cellspacing="0" cellpadding="0"><tr><td><p><span class="stt">matches :: Code -&gt; Code -&gt; Int</span></p></td></tr><tr><td><p><span class="stt">matches xs ys = sum $ map (\(a, b) -&gt; min a b) pairs</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">where pairs = zip (countColors xs) (countColors ys)</span></p></td></tr></table></blockquote><p>The lambda still feels annoying. In fact... looks like ghc-mod is telling me something about a
function called <span class="stt">uncurry</span>. What&rsquo;s its type?</p><blockquote class="code-block"><table cellspacing="0" cellpadding="0"><tr><td><p><span class="stt">(a -&gt; b -&gt; c) -&gt; (a, b) -&gt; c</span></p></td></tr></table></blockquote><p>Oh, <span style="font-style: italic">awesome</span>. This is perfect. In fact... I think this makes my <span class="stt">pairEq</span> function
redundant!</p><blockquote class="code-block"><table cellspacing="0" cellpadding="0"><tr><td><p><span class="stt">exactMatches :: Code -&gt; Code -&gt; Int</span></p></td></tr><tr><td><p><span class="stt">exactMatches xs ys = length . filter id $ map (uncurry (==)) pairs</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">where pairs = zip xs ys</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt">matches :: Code -&gt; Code -&gt; Int</span></p></td></tr><tr><td><p><span class="stt">matches xs ys = sum $ map (uncurry min) pairs</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">where pairs = zip (countColors xs) (countColors ys)</span></p></td></tr></table></blockquote><p>Much nicer on both counts. Of course, this only works on pairs, not other tuples. I seem to remember
that the usual approach to this in Haskell is just to add more functions (or use typeclasses). Maybe
there&rsquo;s an equivalent for three-tuples?</p><p>Well, searching for <span class="stt">(a -&gt; b -&gt; c -&gt; d) -&gt; (a, b, c) -&gt; d</span> gives me nothing, as does <span class="stt">uncurry3</span>.
Maybe it&rsquo;s just not common enough to warrant a built-in function? I&rsquo;ll look into it more if I ever
find myself actually wanting that function.</p><h4>3.2<tt>&nbsp;</tt><a name="(part._.Oh_right__types_are_complicated)"></a>Oh right, types are <span style="font-style: italic">complicated</span></h4><p>The assignment defines a <span class="stt">Move</span> type that consists of a <span class="stt">Code</span> and two <span class="stt">Int</span>s, which
correspond to the number of exact and inexact matches, respectively. It wants me to implement a
function to build a <span class="stt">Move</span> given a guess <span class="stt">Code</span> and the "secret" <span class="stt">Code</span>.</p><p>Well, I already have a function to get the <span style="font-style: italic">exact</span> matches and another function to get <span style="font-style: italic">all</span> the matches, so writing an <span class="stt">inexactMatches</span> function should be pretty simple.</p><blockquote class="code-block"><table cellspacing="0" cellpadding="0"><tr><td><p><span class="stt">inexactMatches :: Code -&gt; Code -&gt; Int</span></p></td></tr><tr><td><p><span class="stt">inexactMatches xs ys = matches xs ys - exactMatches xs ys</span></p></td></tr></table></blockquote><p>You know what, that sucks. To me, this looks like simple composition between the <span class="stt">-</span>, <span class="stt">matches</span>,
and <span class="stt">exactMatches</span> functions. There has to be a way to write this more nicely, right? I seem to
remember that "lambdabot" on #haskell has a point-free generation function (amusingly named
"pointless"), so maybe that will help?</p><p><div class="SIntrapara"><blockquote class="irc-quote"><table cellspacing="0" cellpadding="0"><tr><td><p><span class="stt">&lt;lexi-lambda&gt; @pl \a b -&gt; f a b - g a b</span></p></td></tr><tr><td><p><span class="stt">&lt;lambdabot&gt; ap (ap . ((-) .) . f) g</span></p></td></tr></table></blockquote></div><div class="SIntrapara"><span class="irc-channel">haskell</span></div></p><p>Eww. That&rsquo;s not helpful at all. So much for that idea. Time to actually ask people who know what
they&rsquo;re doing.</p><p><div class="SIntrapara"><blockquote class="irc-quote"><table cellspacing="0" cellpadding="0"><tr><td><p><span class="stt">&lt;lexi-lambda&gt; Fiddling with Haskell, had a random question:</span></p></td></tr><tr><td><p><span class="stt">&lt;lexi-lambda&gt; is there a nicer way to write a function like this?</span></p></td></tr><tr><td><p><span class="stt">&lt;lexi-lambda&gt; \a b -&gt; f a b - g a b</span></p></td></tr></table></blockquote></div><div class="SIntrapara"><span class="irc-channel">haskell</span></div></p><p>I had a few people suggest it looked pretty nice as-is, so maybe I&rsquo;m just being silly. But still,
there <span style="font-style: italic">has</span> to be a nice way to do this, right? It&rsquo;s so simple! I got a few more suggestions,
none of which were any nicer than the original. Here are a few:</p><blockquote class="code-block"><table cellspacing="0" cellpadding="0"><tr><td><p><span class="stt">curry $ (-) &lt;$&gt; uncurry f &lt;*&gt; uncurry g</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt">curry $ liftA2 (-) $ uncurry f $ uncurry g</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt">up op f g x = f x `op` g x</span></p></td></tr><tr><td><p><span class="stt">(^-^) = up (up (-))</span></p></td></tr></table></blockquote><p>Meh. None of those are nice at all.</p><p><div class="SIntrapara"><blockquote class="irc-quote"><table cellspacing="0" cellpadding="0"><tr><td><p><span class="stt">&lt;mniip&gt; getCompose (liftA2 (-) (Compose max) (Compose min))</span></p></td></tr></table></blockquote></div><div class="SIntrapara"><span class="irc-channel">haskell</span></div></p><p>Oh hey, that looks neat! Even if it&rsquo;s not what I&rsquo;d like it to be, that&rsquo;s getting closer. Maybe if I
check out how it works I can bang it into shape. So what exactly are <span class="stt">getCompose</span> and <span class="stt">Compose</span>
and why are they necessary?</p><p>Apparently, <a href="http://hackage.haskell.org/package/transformers-0.4.3.0/docs/Data-Functor-
Compose.html#v:Compose"><span class="stt">Compose</span></a> is for "composition of functors". What am I getting myself
<span style="font-style: italic">into</span>?</p><p>So the documentation says that <span class="stt">Compose</span> has a single data constructor, <span class="stt">Compose</span>. It also lists
a value on the same page called <span class="stt">getCompose</span> that has the type <span class="stt">f (g a)</span>. Wait, <span class="stt">getCompose</span>
doesn&rsquo;t even appear to be a function type? Maybe <span class="stt">f</span> is a partially-applied function type? Or maybe
that doesn&rsquo;t make any sense and I&rsquo;m making a fool of myself and demonstrating that I don&rsquo;t really get
how Haskell&rsquo;s type system works.</p><p>I think it&rsquo;s time to do some reading.</p><h5>3.2.1<tt>&nbsp;</tt><a name="(part._.Monads__functors__and_applicative_functors)"></a>Monads, functors, and applicative functors</h5><p>I decided to go back and ask some more questions on IRC. My immediate confusion was resolved&#8212;
<span class="stt">Compose</span> is a record type, so <span class="stt">getCompose</span> just gets at the field. That makes sense, sort of,
though I still don&rsquo;t really understand how it works. It still feels awfully verbose to me. Why can&rsquo;t
I just do <span class="stt">liftA2 (-) max min</span>?</p><p>Let&rsquo;s hop into GHCi and see if it can help me. What are the types of these two long expressions?</p><blockquote class="code-tty"><table cellspacing="0" cellpadding="0"><tr><td><p><span class="stt">&gt; :t getCompose (liftA2 (-) (Compose max) (Compose min))</span></p></td></tr><tr><td><p><span class="stt">getCompose (liftA2 (-) (Compose max) (Compose min))</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">:: (Ord a, Num a) =&gt; a -&gt; a -&gt; a</span></p></td></tr><tr><td><p><span class="stt">&gt; :t liftA2 (-) max min</span></p></td></tr><tr><td><p><span class="stt">liftA2 (-) max min :: (Ord a, Num (a -&gt; a)) =&gt; a -&gt; a -&gt; a</span></p></td></tr></table></blockquote><p>Alright, so the first one is obviously the type I want. Why does the second one have a constraint
<span class="stt">Num (a -&gt; a)</span> (and can that ever even be possibly instantiated?)? I guess I don&rsquo;t even really know
what <span class="stt">liftA2</span> does.</p><blockquote class="code-tty"><table cellspacing="0" cellpadding="0"><tr><td><p><span class="stt">&gt; :t liftA2</span></p></td></tr><tr><td><p><span class="stt">liftA2 :: Applicative f =&gt; (a -&gt; b -&gt; c) -&gt; f a -&gt; f b -&gt; f c</span></p></td></tr><tr><td><p><span class="stt">&gt; :t liftA2 (-)</span></p></td></tr><tr><td><p><span class="stt">liftA2 (-) :: (Applicative f, Num c) =&gt; f c -&gt; f c -&gt; f c</span></p></td></tr></table></blockquote><p>Okay, so the first argument is pretty obvious, but what is <span class="stt">Applicative</span> and what does it mean
here?</p><blockquote class="blockquote"><p><div class="SIntrapara">A functor with application, providing operations to
</div><div class="SIntrapara"><ul><li><p>embed pure expressions (<span class="stt">pure</span>), and</p></li><li><p>sequence computations and combine their results (<span class="stt">&lt;*&gt;</span>).</p></li></ul></div></p></blockquote><p>Okay, so <span class="stt">Applicative</span> has a function like <span class="stt">Monad</span>&rsquo;s <span class="stt">return</span> to "lift" values, called
<span class="stt">pure</span>. Then it can also sequence values using <span class="stt">&lt;*&gt;</span>. I still have no idea what that means here.
What is <span class="stt">f</span> getting instantiated with?</p><p>Well, I&rsquo;m providing <span class="stt">min</span> and <span class="stt">max</span>, which are functions, and it looks like there&rsquo;s an instance
of <span class="stt">Applicative</span> for <span class="stt">((-&gt;) a)</span>. But what does that instance <span style="font-style: italic">do</span>?</p><p>A quick search has found me a Stack Overflow question, which in turn has redirected me to Chapter 11
of <span style="font-style: italic">Learn You a Haskell</span>. It would probably be helpful for me to read through all of this
patiently but I don&rsquo;t want to do that. Show me the code!</p><blockquote class="code-block"><table cellspacing="0" cellpadding="0"><tr><td><p><span class="stt">instance Applicative ((-&gt;) r) where</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">pure x = (\_ -&gt; x)</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">f &lt;*&gt; g = \x -&gt; f x (g x)</span></p></td></tr></table></blockquote><p>Aha! That&rsquo;s helpful. How was I supposed to know that, anyway? Whatever. It looks like <span class="stt">&lt;*&gt;</span> is just
simple function composition for functions. Or wait, no, that&rsquo;s what <span class="stt">fmap</span> is. This passes <span class="stt">f</span>
two arguments, <span class="stt">x</span> and <span class="stt">(g x)</span>. How is this useful at all?</p><p>(Oh, also, I just learned that <span class="stt">&lt;$&gt;</span> is an abbreviation for <span class="stt">fmap</span>, so that&rsquo;s good to know.)</p><p>Phew. So I&rsquo;ve been reading around on this page for quite a long while now. I sort of understand how
various individual instances of these typeclasses work, but I feel like I&rsquo;m utterly failing to see
any "bigger picture" about what <span style="font-style: italic">all</span> instances of a particular typeclass do. How would I have
<span style="font-style: italic">any</span> idea what <span class="stt">fmap</span> does with <span class="stt">IO</span> if I didn&rsquo;t know the implementation?</p><p>I guess I really just don&rsquo;t see the purpose of having these "general-purpose" typeclasses if the
operations they define are so different in each case that they&rsquo;re really just separate functions for
different types. Or am I missing something that ties them together?</p><h4>3.3<tt>&nbsp;</tt><a name="(part._.It_s_types_all_the_way_down)"></a>It&rsquo;s types all the way down</h4><p>Alright, I finally bit the bullet and took the time to read a fair portion of the RYAH chapter. I&rsquo;m
sure I still barely understand anything, but I think I have enough of an idea to at least reason about
things. From what I can tell, the reason I can&rsquo;t do <span class="stt">liftA2 (-) max min</span> is because my functions
are binary.</p><p>While I <span style="font-style: italic">do</span> now understand how instances of <span class="stt">Applicative</span> can work with <span class="stt">fmap</span> to great
utility, I&rsquo;m still not entirely sure how the whole process works. If I understood the concepts more, I
think just looking at the types of things would be more helpful, but unfortunately, I&rsquo;m not there yet.</p><p>So this does a thing.</p><blockquote class="code-block"><table cellspacing="0" cellpadding="0"><tr><td><p><span class="stt">&gt; (,) &lt;$&gt; (Just) &lt;*&gt; (not) $ True</span></p></td></tr><tr><td><p><span class="stt">(Just True,False)</span></p></td></tr></table></blockquote><p>Which is... cool, I guess? I understand what it does&#8212;it applies the two functions to <span class="stt">True</span>, then
applies the first function to both of them. But why?</p><p>Let&rsquo;s see. Both <span class="stt">&lt;$&gt;</span> and <span class="stt">&lt;*&gt;</span> are left-associative and have the same precedence. What&rsquo;s the
result of the first operation? Well, it&rsquo;s just <span class="stt">fmap (,) Just</span>. What&rsquo;s the implementation of
<span class="stt">fmap</span> on functions? It&rsquo;s just composition, so we get <span class="stt">(,) . Just</span>.</p><p>To make this easier on myself, I&rsquo;ll visualize this as the following:</p><blockquote class="code-block"><table cellspacing="0" cellpadding="0"><tr><td><p><span class="stt">\a b -&gt; (Just a, b)</span></p></td></tr></table></blockquote><p>So now what? Now we get to <span class="stt">&lt;*&gt;</span>. What&rsquo;s <span class="stt">(&lt;*&gt;) (\a b -&gt; (Just a, b)) not</span>?</p><blockquote class="code-tty"><table cellspacing="0" cellpadding="0"><tr><td><p><span class="stt">&gt; :t (&lt;*&gt;) (\a b -&gt; (Just a, b)) not</span></p></td></tr><tr><td><p><span class="stt">(&lt;*&gt;) (\a b -&gt; (Just a, b)) not :: Bool -&gt; (Maybe Bool, Bool)</span></p></td></tr><tr><td><p><span class="stt">&gt; :t (,) &lt;$&gt; (Just) &lt;*&gt; not</span></p></td></tr><tr><td><p><span class="stt">(,) &lt;$&gt; (Just) &lt;*&gt; not :: Bool -&gt; (Maybe Bool, Bool)</span></p></td></tr></table></blockquote><p>Okay. So <span class="stt">a &lt;*&gt; b</span> for functions is just <span class="stt">\x -&gt; a x (b x)</span>. Expanding that out, we get:</p><blockquote class="code-block"><table cellspacing="0" cellpadding="0"><tr><td><p><span class="stt">\x -&gt; (\a b -&gt; (Just a, b)) x (not x)</span></p></td></tr></table></blockquote><p>Well that&rsquo;s remarkably simple. Why is it so hard for me to understand? Maybe because I just don&rsquo;t get
why it&rsquo;s a useful function to have. Why is this such a general pattern? It seems awfully arbitrary.</p><p>I guess all this does is take a function of arity 2 and pass it the result of a single argument
threaded through two functions of arity 1. <span style="font-style: italic">Why is this so important?</span> I don&rsquo;t understand. I&rsquo;m
confused. What about a function of arity 3?</p><blockquote class="code-tty"><table cellspacing="0" cellpadding="0"><tr><td><p><span class="stt">&gt; :t (,,) &lt;$&gt; (Just) &lt;*&gt; (Left) &lt;*&gt; (*3)</span></p></td></tr><tr><td><p><span class="stt">(,,) &lt;$&gt; (Just) &lt;*&gt; (Left) &lt;*&gt; (*3)</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">:: Num a =&gt; a -&gt; (Maybe a, Either a b, a)</span></p></td></tr></table></blockquote><p>Alright, that... actually makes sense. Cool. Just to understand how the extra argument affects things,
let me expand this all out again.</p><blockquote class="code-block"><table cellspacing="0" cellpadding="0"><tr><td><p><span class="stt">(,,) &lt;$&gt; Just = \a b c -&gt; (Just a, b, c)</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">&lt;*&gt; Left = \x -&gt; (\a b c -&gt; (Just a, b, c)) x (Left x)</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">= \x c -&gt; (Just x, Left x, c)</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">&lt;*&gt; (*3) = \y -&gt; (\x c -&gt; (Just x, Left x, c)) y (y * 3)</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">= \y -&gt; (Just y, Left y, y * 3)</span></p></td></tr></table></blockquote><p>Well. I guess the values are proliferated through the argument list by alpha-conversion as the tree
expands, eventually collapsing down to a single-argument function.</p><p>None of this makes my original problem any simpler, though, does it? In all of these cases, the
functions passed in need to be unary. It&rsquo;s been so long I&rsquo;ve almost forgotten my original function.</p><blockquote class="code-block"><table cellspacing="0" cellpadding="0"><tr><td><p><span class="stt">\a b -&gt; (f a b) - (g a b)</span></p></td></tr></table></blockquote><p>Now I&rsquo;m sort of curious... how can I generalize some system for transforming <span class="stt">(-)</span> into a function
that will accept four arguments: two functions and two values to apply to those functions. Wouldn&rsquo;t
this be theoretically pretty similar to <span class="stt">&lt;*&gt;</span>? Obviously the simple way would be doing this:</p><blockquote class="code-block"><table cellspacing="0" cellpadding="0"><tr><td><p><span class="stt">lift op f g x y = op (f x y) (g x y)</span></p></td></tr></table></blockquote><p>But that&rsquo;s terribly uninteresting and specialized. Ideally what I&rsquo;d want would be some series of
operations that would compound a function that takes <span style="font-style: italic">n</span> values with <span style="font-style: italic">n</span> functions of
arity 2 and produce a function that accepts 2 values and produces a result.</p><p>Well, let&rsquo;s call my magic operator <span class="stt">&lt;**&gt;</span>, and the lifting operator (the equivalent of <span class="stt">pure</span>)
will be called <span class="stt">pure2</span>. Do these names make sense? Probably not. I don&rsquo;t care.</p><p>Therefore, my function should look like this:</p><blockquote class="code-block"><table cellspacing="0" cellpadding="0"><tr><td><p><span class="stt">inexactMatches = pure2 (-) &lt;**&gt; matches &lt;**&gt; exactMatches</span></p></td></tr></table></blockquote><p>(Wow, I really had to think for a moment there to remember what I was originally trying to solve.)</p><p>So how should this expand, ideally? Well, maybe if I write out the expansion steps like I did above, a
more general pattern will appear.</p><blockquote class="code-block"><table cellspacing="0" cellpadding="0"><tr><td><p><span class="stt">pure2 o = \_ _ a b -&gt; (o a b)</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span><span class="stt">&lt;**&gt; f = \x y -&gt; (\_ _ a b -&gt; (o a b)) x y (f x y)</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">= \x y -&gt; (\a b -&gt; (o a b)) (f x y)</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span><span class="stt">&lt;**&gt; g = \p q -&gt; (\x y -&gt; (\a b -&gt; (o a b)) (f x y)) p q (g p q)</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">= \p q -&gt; (\a b -&gt; (o a b)) (f p q) (g p q)</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">= \p q -&gt; o (f p q) (g p q)</span></p></td></tr></table></blockquote><p>Hey! That&rsquo;s not special at all, that&rsquo;s actually just a different implementation of <span class="stt">Applicative</span>
for functions. It may have taken me thirty minutes just to figure out how that should properly expand,
but now that I&rsquo;ve done it, it seems pretty obvious.</p><h5>3.3.1<tt>&nbsp;</tt><a name="(part._.Build_your_own_instances__maybe_)"></a>Build your own instances&#8230; maybe?</h5><p>So then how can I make this "alternate" instance for the same type? Well, I don&rsquo;t think I can, but
maybe I can do it by making a small wrapper type. I seem to remember reading something like that ages
ago.</p><p>Okay, so first I need to define my wrapper type.</p><blockquote class="code-block"><table cellspacing="0" cellpadding="0"><tr><td><p><span class="stt">newtype BinaryFunction a b = BinaryFunction (a -&gt; b)</span></p></td></tr></table></blockquote><p>That seems right. Now I need to implement a <span class="stt">Functor</span> instance for it, which should still just be
function composition.</p><blockquote class="code-block"><table cellspacing="0" cellpadding="0"><tr><td><p><span class="stt">instance Functor (BinaryFunction a) where</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">fmap a (BinaryFunction b) = BinaryFunction (a . b)</span></p></td></tr></table></blockquote><p>Then all that&rsquo;s left to do is implement <span class="stt">Applicative</span>.</p><blockquote class="code-block"><table cellspacing="0" cellpadding="0"><tr><td><p><span class="stt">instance Applicative (BinaryFunction a) where</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">pure f = BinaryFunction (\_ _ -&gt; f)</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">(BinaryFunction f) &lt;*&gt; (BinaryFunction g) = BinaryFunction (\x y -&gt; f x y (g x y))</span></p></td></tr></table></blockquote><p>Hmm, that doesn&rsquo;t work, but I&rsquo;m not sure why. I think it&rsquo;s because <span class="stt">g</span>&rsquo;s type implies it can only
be applied to one argument and <span class="stt">f</span>&rsquo;s type implies it can only be applied to one. So maybe I need to
modify my <span class="stt">newtype</span> wrapper to explicity declare it can take two arguments?</p><blockquote class="code-block"><table cellspacing="0" cellpadding="0"><tr><td><p><span class="stt">newtype BinaryFunction a b c = BinaryFunction (a -&gt; b -&gt; c)</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt">instance Functor (BinaryFunction a b) where</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">fmap a (BinaryFunction b) = BinaryFunction (a . b)</span></p></td></tr></table></blockquote><p>Wait, no, now <span class="stt">fmap</span> is giving me errors. It seems that now, since <span class="stt">a</span> can only be applied to a
single argument, this no longer works. Darn.</p><p>Is it possible that this isn&rsquo;t an <span class="stt">Applicative</span> after all? What if I tried implementing my own
typeclass with the slightly different behavior? Would that work, or is my conclusion incorrect?</p><blockquote class="code-block"><table cellspacing="0" cellpadding="0"><tr><td><p><span class="stt">class BinaryFunctor a where</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">fmap2 :: </span></p></td></tr></table></blockquote><p>Wait, how does this even work? I think the original <span class="stt">Applicative</span> law should have an analogue here.</p><blockquote class="code-block"><table cellspacing="0" cellpadding="0"><tr><td><p><span class="stt">fmap2 f g = pure2 f &lt;*&gt; g</span></p></td></tr></table></blockquote><p>Reasoning backwards from my "definitions" for <span class="stt">pure2</span> and <span class="stt">&lt;*&gt;</span>...</p><blockquote class="code-block"><table cellspacing="0" cellpadding="0"><tr><td><p><span class="stt">pure2 f &lt;*&gt; g = \x y -&gt; (\_ _ a b -&gt; (f a b)) x y (g x y)</span></p></td></tr></table></blockquote><p>That seems right... although honestly at this point I don&rsquo;t have any idea if what I&rsquo;m doing makes any
sense anymore. Anyway, if I define <span class="stt">fmap2</span> just for functions, I get this.</p><blockquote class="code-block"><table cellspacing="0" cellpadding="0"><tr><td><p><span class="stt">fmap2 :: (a -&gt; b -&gt; c) -&gt; (d -&gt; e -&gt; a) -&gt; d -&gt; e -&gt; b -&gt; c</span></p></td></tr><tr><td><p><span class="stt">fmap2 f g = \x y -&gt; (\_ _ -&gt; f) x y (g x y)</span></p></td></tr></table></blockquote><p>Wow. That was much more complicated than I expected, honestly. Maybe this is a little less
generalizable than I thought. In fact, is it even possible? The type of <span class="stt">fmap</span> is pretty simple.</p><blockquote class="code-tty"><table cellspacing="0" cellpadding="0"><tr><td><p><span class="stt">&gt; :t fmap</span></p></td></tr><tr><td><p><span class="stt">fmap :: Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b</span></p></td></tr></table></blockquote><p>Specialized for function types, that&rsquo;s still pretty straightforward.</p><blockquote class="code-block"><table cellspacing="0" cellpadding="0"><tr><td><p><span class="stt">fmap :: (a -&gt; b) -&gt; (r -&gt; a) -&gt; (r -&gt; b)</span></p></td></tr></table></blockquote><p>But with my <span class="stt">fmap2</span>, the arity of the resulting function is different from the arity of the second
argument, so it doesn&rsquo;t seem like they could possibly be represented by the same type, anyway.</p><p>It&rsquo;s clear I&rsquo;m in <span style="font-style: italic">way</span> over my head on this one. I don&rsquo;t really have any idea what I&rsquo;m doing.
What was I supposed to be doing in the first place?</p><h4>3.4<tt>&nbsp;</tt><a name="(part._.Back_to_.Mastermind)"></a>Back to <span style="font-style: italic">Mastermind</span></h4><p>Right. <span style="font-style: italic">Mastermind</span>. That was a quite the detour. Maybe I&rsquo;ll come back to it later, or maybe
I&rsquo;ll just realize that what I was trying to do was misguided and didn&rsquo;t make any sense anyway. Who
knows? Whatever. I should probably just finish what I was working on before all this nonsense got me
distracted.</p><blockquote class="code-block"><table cellspacing="0" cellpadding="0"><tr><td><p><span class="stt">inexactMatches :: Code -&gt; Code -&gt; Int</span></p></td></tr><tr><td><p><span class="stt">inexactMatches xs ys = matches xs ys - exactMatches xs ys</span></p></td></tr></table></blockquote><p><span style="font-weight: bold">Fine.</span> You know what? It&rsquo;s good enough. <span style="font-weight: bold">Moving on.</span></p><blockquote class="blockquote"><p>A <span class="stt">Move</span> is a new datatype that is constructed with a <span class="stt">Code</span> and two <span class="stt">Int</span>s. The first
<span class="stt">Int</span> is the number of exact matches that the <span class="stt">Code</span> has with the secret and the second <span class="stt">Int</span>
is the number of nonexact matches.</p></blockquote><p>Alright, this is pretty stupidly easy compared to what I was just dealing with.</p><blockquote class="code-block"><table cellspacing="0" cellpadding="0"><tr><td><p><span class="stt">getMove :: Code -&gt; Code -&gt; Move</span></p></td></tr><tr><td><p><span class="stt">getMove secret guess = Move secret e i</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">where e = exactMatches secret guess</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">i = inexactMatches secret guess</span></p></td></tr></table></blockquote><p>Is it beautiful? No. Does it work? Yes. Good.</p><blockquote class="blockquote"><p>We will now define a concept that will be important in playing the Mastermind game. This is the
concept of <span style="font-style: italic">consistency</span>; we say that a <span class="stt">Code</span> is consistent with a <span class="stt">Move</span> if the
<span class="stt">Code</span> could have been the secret that generated that move. In other words, if the guess inside the
<span class="stt">Move</span> has the same number of exact and non-exact matches with the provided Code as it did with the
actual secret, then the <span class="stt">Code</span> is consistent with the <span class="stt">Move</span>.</p></blockquote><blockquote class="code-block"><table cellspacing="0" cellpadding="0"><tr><td><p><span class="stt">isConsistent :: Move -&gt; Code -&gt; Bool</span></p></td></tr><tr><td><p><span class="stt">isConsistent (Move guess e i) guess' = e == e' &amp;&amp; i == i'</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">where e' = exactMatches guess' guess</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">i' = inexactMatches guess' guess</span></p></td></tr></table></blockquote><p>Easy stuff. Now we just implement a function to filter out all the remaining viable codes.</p><blockquote class="code-block"><table cellspacing="0" cellpadding="0"><tr><td><p><span class="stt">filterCodes :: Move -&gt; [Code] -&gt; [Code]</span></p></td></tr><tr><td><p><span class="stt">filterCodes m = filter $ isConsistent m</span></p></td></tr></table></blockquote><p>Now we just need to create a function that will generate all possible permutations of a list of colors
given a certain code length.</p><blockquote class="code-block"><table cellspacing="0" cellpadding="0"><tr><td><p><span class="stt">allCodes :: Int -&gt; [Code]</span></p></td></tr><tr><td><p><span class="stt">allCodes 0 = []</span></p></td></tr><tr><td><p><span class="stt">allCodes 1 = map (:[]) colors</span></p></td></tr><tr><td><p><span class="stt">allCodes n = concatMap (\c -&gt; map (c:) $ allCodes (n - 1)) colors</span></p></td></tr></table></blockquote><p>Now we can write a function that actually solves Mastermind puzzles. The assignment wants me to always
start by guessing purely <span class="stt">Red</span> just for consistency.</p><blockquote class="code-block"><table cellspacing="0" cellpadding="0"><tr><td><p><span class="stt">solve :: Code -&gt; [Move]</span></p></td></tr><tr><td><p><span class="stt">solve secret = loop [initialMove]</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">where codeLen = length secret</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">initialMove = getMove secret $ replicate codeLen Red</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">isConsistentWithAll ms c = all (`isConsistent` c) ms</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">nextMove ms = getMove secret $ head $ filter (isConsistentWithAll ms) $ allCodes codeLen</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">loop ms@(Move _ e _ : _)</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">| e == codeLen = ms</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">| otherwise</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">= loop (nextMove ms : ms)</span></p></td></tr></table></blockquote><p>I&rsquo;m sure that could be much more efficient (it filters through the entire list of moves every time
instead of just threading a list of remaining options through), but I don&rsquo;t really care for this small
problem. I&rsquo;ve overengineered this assignment enough, and honestly, I&rsquo;m ready to move on.</p><div class="navsetbottom"><span class="navleft"><div class="nosearchform"></div>&nbsp;&nbsp;</span><span class="navright">&nbsp;&nbsp;<a href="day-1.html" title="backward to &quot;2 Day 1: Getting up and running&quot;" data-pltdoc="x">&larr; prev</a>&nbsp;&nbsp;<a href="index.html" title="up to &quot;Learning Haskell&quot;" data-pltdoc="x">up</a>&nbsp;&nbsp;<span class="nonavigation">next &rarr;</span></span>&nbsp;</div></div></div><div id="contextindicator">&nbsp;</div></body></html>